{"componentChunkName":"component---src-templates-blog-template-blog-template-tsx","path":"/blog/2019-06-23-ajax-and-the-halting-problem/","result":{"data":{"markdownRemark":{"html":"<p>I was asked to analyze the relationship between\nsearch ranking and the amount of\n<a href=\"https://en.wikipedia.org/wiki/Ajax_(programming)\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Ajax</a>\nused in the page.\nThe pages that do not use any Ajax to inject dynamic\ncontent are called static pages.\nThose that do are called dynamic pages.</p>\n<p>Regardless of how I derive the relationship,\nthe first thing to do is to obtain the answers for\nsome questions about one single page.</p>\n<ol>\n<li>How much impact does Ajax have on the page?</li>\n</ol>\n<p>To answer this, ideally, we need to know a few things.</p>\n<ol start=\"2\">\n<li>Are there Ajax used in the page at all?</li>\n<li>When do Ajax calls finish?</li>\n</ol>\n<p>If the answer to 2 is yes, then it is dynamic.\nOtherwise, it is a static page.</p>\n<p>Question 3 is necessary. If we simply request\nfor the page and start analyzing it right away\nwithout waiting for the potential Ajax calls\nto add content to the page, then it is pretty pointless.\nFor instance, you request for Facebook’s feed page and\ndo not wait for the remote to fetch you the posts before\nyou start analyzing it. All you will be looking at its\nthe loading page without the content.</p>\n<h4 id=\"the-answer-as-a-human\" style=\"position:relative;\"><a href=\"#the-answer-as-a-human\" aria-label=\"the answer as a human permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Answer (as a human)</h4>\n<p>As a human, we can see the impact of Ajax on the page.\nFor instance, when you just open Facebook or Youtube,\nit takes a while for the posts and videos to show up.\nHowever, it sometimes can happen so fast with good\nnetwork condition and fast computer that we barely\nsee the change.\nBut, we can always use the <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"script\">C</mi><mi>h</mi><mi>r</mi><mi>o</mi><mi>m</mi><mi>e</mi><mtext>  </mtext><mi>D</mi><mi>e</mi><mi>v</mi><mtext>  </mtext><mi>T</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi>s</mi></mrow><annotation encoding=\"application/x-tex\">\\mathcal Chrome\\;Dev\\;Tools</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.6944em;\"></span><span class=\"mord mathcal\" style=\"margin-right:0.05834em;\">C</span><span class=\"mord mathnormal\">h</span><span class=\"mord mathnormal\">ro</span><span class=\"mord mathnormal\">m</span><span class=\"mord mathnormal\">e</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\">De</span><span class=\"mord mathnormal\" style=\"margin-right:0.03588em;\">v</span><span class=\"mspace\" style=\"margin-right:0.2778em;\"></span><span class=\"mord mathnormal\" style=\"margin-right:0.13889em;\">T</span><span class=\"mord mathnormal\">oo</span><span class=\"mord mathnormal\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathnormal\">s</span></span></span></span></span>,\nwhich is everybody’s favorite.</p>\n<p>This is the time where the Network tab shines.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6a274320fd8296f2c4fcabc37ba5f99d/7e21b/network-tab.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 48.75000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB9UlEQVQoz2WSy2rdMBRF/f+zfkOh80KnhULJMCRp2oY29yaxr235JVsPy5Yf8ip2Ouhjw+EcJLE4aO8oK2ueTs8UWUqSJGS5IC9Kznd3PF1fk58fSc4nsiwjjuPjjRCCNE1JLxfi5HLc1VWFUopIWYfVFmcNnVIkyYU0L0mTC6e7W+rvXxAP30izjKIof/eCNM/J8hyZpyhjsNaitSbiD23bxjzPzPN0VO8crhS4Msfts3MMw4C1PYNzLJVgU5LQFKzOsgHRugb2KazrjjwOd607eJrww8A0DPjR48eJye99ZPYeBgdhg3l5XShsRFpJ+tFSdprOeeo6RaiS1nnacUBZRTv2dEYilaAQFZU2dNbws4p50TWPdcxNdk8iKyK8I2TPBKOYZc08GOz0upFMTtjTDT/khbJPOZ8/8/H+E19dS6sNb2/f8+b0gXcvV1zVD8RjRySbhi5+QkpJbwzGGOqmPlzLLwVVlqOblrbM0IWgqWuEqmiUpFItRVvS6JbZz0zDSCRli24alNaM3uN6R/FcIkRNpzVVXdO0LXsapNKHMePg6Xv3+sejZ13Ww9CwbUTjOBJCYF2Ww9llXjDCHuB1XVjDxtIbQpWzVgJ6A85CW+2x+CshuyLb96/Oec8OX5aF/xQCjA6WhS0EtnVlm6cD8m/9Ah3d+aTKZ21TAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"network-tab.png\"\n        title=\"network-tab.png\"\n        src=\"/static/6a274320fd8296f2c4fcabc37ba5f99d/6af66/network-tab.png\"\n        srcset=\"/static/6a274320fd8296f2c4fcabc37ba5f99d/69538/network-tab.png 160w,\n/static/6a274320fd8296f2c4fcabc37ba5f99d/72799/network-tab.png 320w,\n/static/6a274320fd8296f2c4fcabc37ba5f99d/6af66/network-tab.png 640w,\n/static/6a274320fd8296f2c4fcabc37ba5f99d/d9199/network-tab.png 960w,\n/static/6a274320fd8296f2c4fcabc37ba5f99d/21b4d/network-tab.png 1280w,\n/static/6a274320fd8296f2c4fcabc37ba5f99d/7e21b/network-tab.png 1626w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>We can see all the network activities,\nincluding the request and response information.\nThe Network tab also allows us to filter request based\non the type of data requested. What we really care about is\n<a href=\"https://en.wikipedia.org/wiki/XMLHttpRequest\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">XHR</a>.\nThe XHR responses consist of XML (which includes HTML),\n<a href=\"https://www.json.org/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JSON</a>, or other data format that\ncan be potentially be placed on the page dynamically.</p>\n<p>The waterfall allows us to select a chunk of time\nand looks at all the request and response within the\nselected timeframe. The filmstrip is a series of\nscreenshots taken to let us see the change in the page\nvisually.</p>\n<p>As a human, we can look at each request and its impact\non the page by looking at the filmstrip. Then, we can\ndetermine how much contents are rendered or dynamically\nput on to the page. You may be able to see a problem\nhere. It is quite hard to quantify the amount of impact\nby Ajax just by looking at the filmstrip.</p>\n<p>So far, we are running into 2 major hurdles.</p>\n<ol>\n<li>There is a difficulty to quantify how much Ajax impact\nthe page just by looking at the filmstrip visually.</li>\n<li>This is not scalable. As a human, it will take up\ntoo much valuable time to analyze 10 pages. Don’t even\nthink about 100 pages, or 1000 pages.</li>\n</ol>\n<h4 id=\"the-answer-as-a-machine\" style=\"position:relative;\"><a href=\"#the-answer-as-a-machine\" aria-label=\"the answer as a machine permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Answer (as a machine)</h4>\n<p>We can easily solve the issue of scalability easily\nwith computers. They are built for exactly this purpose.</p>\n<p>To analyze a static webpage with a machine, we use the\ngood old web parser approach. Request for the page,\nget its HTML text. However, since we are looking at pages\nwith Ajax, we need a JavaScript runtime to run the\nscripts. This problem has been solved with\n<a href=\"https://selenium-python.readthedocs.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">selenium</a>,\na browser automation tool mostly used for testing.\nPeople have been repurposing it to parse pages with Ajax\nrequests.</p>\n<p>Now, we have the tools. Next, we answer the questions\nwith these tools. Let’s first tackle 2.</p>\n<blockquote>\n<p>2. Are there Ajax used in the page at all?</p>\n</blockquote>\n<p>As a human, we can inspect the network tab.\nIf there are XHR requests that have an impact on the\n<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">DOM</a>\n(visually), then there is Ajax.\nThe machine can do the same. It waits for XHR requests\nto finish, then checks if the DOM changed, which is\nway more “accurate” than just visual inspection of the\nfilmstrip.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 640px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c0bf0736749701a044afe62f14251cfe/cad61/flow.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.625%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABFklEQVQoz3WRDW+CMBCG/f8/0MxlIigKShGlpQX68SwturhlXnJp2rv36bXvCgIpgsd7j3WOeZ6x1mKMwc4jj4Z0Nk0TISya1/WZq8FYlLac6paiKMi2WzabT6rTiUNZcah6bsrTD47dLqOu6yR0ziVYvPwVvPra5uR5TtMqpFLI5oLse5SSdPeBrKhYrz84C8V+v6dpGkTbJk1ZlmRZhhCC6/W6AEUXQSPKgHUBPxqcMaloRkt7Gzk3HaLTaQrvA5NSaClRw5Am1FojpVyAcVoflsZnhNHE+RdAWH45pXMEY+I7+S8SMBrxlKSPTf54/L37AYdpJMg+7WMt/DHilyn+TYPvWlx9xFUlrjoS9PDw+j0sAr8BpYIhMrNOHKIAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"flow.png\"\n        title=\"flow.png\"\n        src=\"/static/c0bf0736749701a044afe62f14251cfe/6af66/flow.png\"\n        srcset=\"/static/c0bf0736749701a044afe62f14251cfe/69538/flow.png 160w,\n/static/c0bf0736749701a044afe62f14251cfe/72799/flow.png 320w,\n/static/c0bf0736749701a044afe62f14251cfe/6af66/flow.png 640w,\n/static/c0bf0736749701a044afe62f14251cfe/d9199/flow.png 960w,\n/static/c0bf0736749701a044afe62f14251cfe/21b4d/flow.png 1280w,\n/static/c0bf0736749701a044afe62f14251cfe/cad61/flow.png 1988w\"\n        sizes=\"(max-width: 640px) 100vw, 640px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>Seems easy enough.\nWith a proper DOM compare methodology, we can answer\nquestion 1.\nThe only question left is 3.</p>\n<blockquote>\n<p>3. When do Ajax calls finish?</p>\n</blockquote>\n<p>We need to tell the code when the best time is to\ntake the second screenshot of the DOM, which is when\nall the Ajax has finished and dynamic content has been\ninjected into the page.</p>\n<p>As a human, this seems like an easy enough issue.\nWe stare at the network tab until there is no more\nactivity. Then, we can claim that all Ajax are done.</p>\n<p>However, the same approach seems quite unreasonable to\na machine. The machine cannot look at the network tab\nand determine when there is “no more activity”.\nIt might be able to determine if there are requests\nthat have not yet received a response. But, it is quite\nhard to know if there will be more requests after\nthe current batch of requests is done.</p>\n<h5 id=\"attempt-1-explicit-wait\" style=\"position:relative;\"><a href=\"#attempt-1-explicit-wait\" aria-label=\"attempt 1 explicit wait permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Attempt 1: Explicit Wait</h5>\n<p>I turned to StackOverflow and Google for an answer.\nThe suggested way is to use the\n<a href=\"https://selenium-python.readthedocs.io/waits.html#explicit-waits\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">explicit wait API</a>,\nwhich listens for a certain condition in the DOM.\nThe code is blocked until the condition is achieved.\nQuite dangerous if you think about it.\nWhat if there was network error and the dynamic\ncontent is not rendered on the page? Your code will be\nblocked forever. However, there is an option is to set\na timeout, which help solves this issue.</p>\n<p>Explicit wait fails to address the problem.\nWe are looking at unknown pages. We cannot possibly\nknow where the DOM will be changing for a generic page.</p>\n<h5 id=\"attempt-2-implicit-wait\" style=\"position:relative;\"><a href=\"#attempt-2-implicit-wait\" aria-label=\"attempt 2 implicit wait permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Attempt 2: Implicit Wait</h5>\n<p>Another API that might be useful is the\n<a href=\"https://selenium-python.readthedocs.io/waits.html#implicit-waits\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">implicit wait API</a>.\nIt waits for a specified amount of time.\nThere are usually 2 problems, whenever our code\nspecifies to wait for a specific amount of time.\n<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>1</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(1)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">1</span><span class=\"mclose\">)</span></span></span></span></span> It is not efficient since the Ajax might be\ndone before the timeout. The code will be idle for\nthe extra seconds, wasting our time.\n<span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mo stretchy=\"false\">(</mo><mn>2</mn><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">(2)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mopen\">(</span><span class=\"mord\">2</span><span class=\"mclose\">)</span></span></span></span></span> Even worse, what if the Ajax is slow and does\nnot finish before the timeout?</p>\n<p>Therefore, implicit wait is not a good solution.</p>\n<h5 id=\"attempt-n-random-brainstorming\" style=\"position:relative;\"><a href=\"#attempt-n-random-brainstorming\" aria-label=\"attempt n random brainstorming permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Attempt <span class=\"math math-inline\"><span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>n</mi></mrow><annotation encoding=\"application/x-tex\">n</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.4306em;\"></span><span class=\"mord mathnormal\">n</span></span></span></span></span>: Random Brainstorming</h5>\n<p>Well, if waiting does not work, we might have to probe\nthe DOM or the browser runtime more actively for\ninformation.</p>\n<p>Maybe we can check if the stack is empty.\nHowever, the stack can’t really be empty since there\nis always the main event loop function.\nSo we can check if the stack contains only the main\nevent loop function.\nBut what about the code that is under perhaps a\n<code class=\"language-text\">setTimeout</code> call? What about the event listener code?\nFor instance, what if all the code are put under\n<code class=\"language-text\">window.onload</code>?</p>\n<p>Yes, this is getting complicated. That is exactly the\npoint. This is a difficult problem.\nIt is now a good time to give up on looking for a\nperfect solution.</p>\n<p>Instead of blindly looking for a solution,\nwhy don’t we consider if the problem is solvable at all?</p>\n<h4><strong>I am going to argue there is no solution.</strong></h4>\n<p>I claim that a solution does not exist.</p>\n<h4 id=\"the-halting-problem\" style=\"position:relative;\"><a href=\"#the-halting-problem\" aria-label=\"the halting problem permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The Halting Problem</h4>\n<p>Read about it <a href=\"https://en.wikipedia.org/wiki/Halting_problem\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a>.\nIt is a well-known problem that currently has no\nsolution. From my algorithm class (CS180), to prove\na problem is unsolvable (in some polynomial time),\nwe transform the problem into another known unsolvable\nproblem. Therefore, analogous, we transform our Ajax problem\ninto the halting problem.</p>\n<p>In fact, what we are trying to do is predict when all\nAjax calls finish, which is a subset of the problem\nwhen the program exits.</p>\n<p>We imagine one case with the following pseudo-code.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">while</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> \n    <span class=\"token function\">Ajax</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>That’s it. The <code class=\"language-text\">Ajax()</code> function is being put into\nan infinite loop. Then, we ask question 3 again.\nWe obtain a case where Ajax call cannot terminate.\nOne might question if real production code uses an\ninfinite loop.\nThe answer is no, but yes.\nThere is no way that a person will write an infinite\nwhile loop in production code. But someone can\nwrite this.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">setInterval</span><span class=\"token punctuation\">(</span>Ajax_and_Update_DOM<span class=\"token punctuation\">,</span> <span class=\"token number\">3000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This logically is equivalent to an infinite loop.\nThese types of pattern occur when the frontend has to\nconstantly poll from the backend for live updated\ninformation. Libraries such as\n<a href=\"https://socket.io/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Socket.IO</a> are built for this\nexact reason.</p>\n<p>One way to think about this is that a machine can never\ndetect an infinite loop. Therefore, our code can never\n<strong>predict</strong> whenever the code has finished running.\nChecking if the stack is empty is not a way to predict\nif the program halts. It is asking if the program has\nhalted <strong>right now</strong>.</p>\n<h4 id=\"final-solution\" style=\"position:relative;\"><a href=\"#final-solution\" aria-label=\"final solution permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Final Solution?</h4>\n<p>We proved that there is no solution. Great. So what now?\nWe look back to our seemingly impossible solution,\nthe Implicit Wait.</p>\n<p>Yes, we blindly wait for the page to load and wish\nfor something to happens.\nAs a human, that is what we do.\nWe are good at these type of things, detecting the\nchanges and notice the rate of change is slowing down.</p>\n<h4 id=\"measurement-of-impact\" style=\"position:relative;\"><a href=\"#measurement-of-impact\" aria-label=\"measurement of impact permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Measurement of Impact</h4>\n<p>I have not really thought through how to measure the\nimpact of Ajax on the page.</p>\n<p>My initial idea is to use the <code class=\"language-text\">diff</code>\n(read the <a href=\"http://man7.org/linux/man-pages/man1/diff.1.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">man page</a>)\nprogram to count the number of lines changed on the page.\nThere is a problem of minified file. It does not\nreally work well with <code class=\"language-text\">diff</code> since everything\ncan possibly be on the same line.\nOne way to circumvent is to use\n<a href=\"https://www.crummy.com/software/BeautifulSoup/bs4/doc/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">BeautifulSoup</a>\nto print the beautified DOM and compare them.</p>\n<p>Again, I have not really thought through this but\nwe will see.</p>\n<h4 id=\"conclusion\" style=\"position:relative;\"><a href=\"#conclusion\" aria-label=\"conclusion permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusion</h4>\n<p>In short, predicting if all Ajax has ended is an\nunsolvable problem that we just have to ballpark.</p>\n<h4 id=\"afterthoughts-september-2019\" style=\"position:relative;\"><a href=\"#afterthoughts-september-2019\" aria-label=\"afterthoughts september 2019 permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Afterthoughts (September 2019)</h4>\n<p>This post is written at the beginning of my internship.\nOver the course of it, I also learned how to use\n<a href=\"https://github.com/GoogleChrome/puppeteer/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">puppeteer</a>,\nwhich in my humble opinion is better than selenium.\nPuppeteer provides an API <code class=\"language-text\">waitForNavigation</code>\n(read docs <a href=\"https://pptr.dev/#?product=Puppeteer&#x26;version=v1.19.0&#x26;show=api-pagewaitfornavigationoptions\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">here</a>)\nwhich has an option for us to wait until the “network is\nidle”. Taken straight from the documentation, network idle\nis defined as:</p>\n<ul>\n<li><code class=\"language-text\">networkidle0</code> - consider navigation to be finished when there are no more than 0 network connections for at least 500 ms.</li>\n<li><code class=\"language-text\">networkidle2</code> - consider navigation to be finished when there are no more than 2 network connections for at least 500 ms.</li>\n</ul>\n<p>This is indeed a much smarter and more efficieny way compared\nto using implicit wait. However, my point is still valid as\nin that this does not solve the halting problem. Puppeteer\nis not checking to see when the network <strong>will</strong> be idle in\nthe future, but check if the network is <strong>currently</strong> idle\nand has been <strong>idle</strong> for the past 500 ms.\nFor the sake of efficiency, however, if I had to do it again,\nI would do it in puppeteer instead of selenium.</p>","frontmatter":{"date":"2019-06-23","title":"Ajax and the Halting Problem","subtitle":"How can we tell if Ajax calls are done? We cannot."},"timeToRead":9}},"pageContext":{"slug":"/2019-06-23-ajax-and-the-halting-problem/","prev":{"title":"Measuring Impact of Ajax on a Webpage","path":"/blog/2019-06-26-measurement-of-ajax/2-ajax-measurement/"},"next":{"title":"Parsing TripAdvisor for Hotel URLs","path":"/blog/2019-06-22-tripadvisor-url-parsing/"}}},"staticQueryHashes":["1827841","1979163989"]}