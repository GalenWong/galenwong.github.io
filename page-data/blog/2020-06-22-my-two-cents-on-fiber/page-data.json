{"componentChunkName":"component---src-templates-blog-template-blog-template-tsx","path":"/blog/2020-06-22-my-two-cents-on-fiber/","result":{"data":{"markdownRemark":{"html":"<p>I have been trying to understand the “Fiber” thingy in React for a while. Looking at documents\nlike <a href=\"https://github.com/acdlite/react-fiber-architecture\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">this</a> and\n<a href=\"https://blog.logrocket.com/deep-dive-into-react-fiber-internals/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">this</a> helps… like a little\nbit, until I saw this <a href=\"https://www.youtube.com/watch?v=ZCuYPiUIONs\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">video</a>. This is a really\ngreat watch and I recommend you guys through the whole thing to gain a deeper understanding of the\nFiber architecture.</p>\n<p>Comprehending the “Fiber” concept is definitely not easy… or is it? I think the existing\narticles explain Fiber by showing <em>how</em> it works, by showing the internal data structure.\nAs a person who is a big fan of problem-based learning, I like to present a topic by motivating\nit with an issue first. The key motivating question here is “what is Fiber trying to solve?”\nWe can only grasp the solution only if we grasp the problem well.</p>\n<p>Therefore, I am offering my 2 cents on how <strong>I, myself</strong> understand Fiber, from a perspective\nof the scheduling problem, very much like in the OS. Notice that in the title I did not\nmention React at all, since I would like to stress that the <strong>concept is applicable not only\nto React</strong>, but to the problem of scheduling in general.</p>\n<h2 id=\"asynchronous-execution-model-of-javascript\" style=\"position:relative;\"><a href=\"#asynchronous-execution-model-of-javascript\" aria-label=\"asynchronous execution model of javascript permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Asynchronous Execution Model of JavaScript</h2>\n<p>Before digging too deep, let’s go over a high level overview of the environment where Fiber\nwill get executed, the JavaScript runtime. First, we start with a world without asynchronicity,\nwhere everything is synchronous. In the simplest world of C, we have the following\nmodel of a function stack:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+-------+\n| func2 |\n+-------+\n| func1 |\n+-------+\n| main  |\n+-------+</code></pre></div>\n<p>The rule is simple: when a function is called, a function frame is added to the stack.\nWhen a function returns, a function frame is removed/popped off the stack.\nIt grows upwards, shrinks downwards. The program execution is done when the call stack is empty.</p>\n<p>One thing at a time, it is simple, easy, but slow. The hardware people came up with the\nmulti-core architecture. We would like to leverage that and the OS scheduler to do\nthings faster. We introduces process and threads.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">   T1    \t\tT2\n+-------+    +-------+\n| func2 |    | func3 |\n+-------+    +-------+\n| func1 |    | func4 |\n+-------+    +-------+\n| main  |    | main  |\n+-------+    +-------+</code></pre></div>\n<p>This is nice, but threads are susceptible to race conditions. T1 and T2 can be accessing\nthe same variable at the same time. That’s nasty. Let’s keep things single threaded. No race conditions.\nTo improve performance, we rethink what is taking so much time.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+---------+-----------+----------------------------+---------------------+-------------+-------------+\n| program | read file |                            | do things with file | do things 1 | do things 2 |\n+---------+-----------+----------------------------+---------------------+-------------+-------------+\n| OS      |           |            I/O             |                     |             |             |\n+---------+-----------+----------------------------+---------------------+-------------+-------------+</code></pre></div>\n<p>Can we make use of the time when the OS is doing I/O to do other things, since during I/O\nthe CPU is really not doing anything? But how can we do that without using threads?</p>\n<h3 id=\"introducing-callbacks\" style=\"position:relative;\"><a href=\"#introducing-callbacks\" aria-label=\"introducing callbacks permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introducing: <em><strong>Callbacks</strong></em></h3>\n<blockquote>\n<p>Program: JS engine, help me read a file/make a network call. When you are done, do the following things with the result.</p>\n</blockquote>\n<p>callback = “do the following things”</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">+---------+-----------+-------------+-------------+-----------+--------------------------------+\n| program | read file | do things 1 | do things 2 |           | do things with file (callback) |\n+---------+-----------+-------------+-------------+-----------+--------------------------------+\n| OS      |           |                  I/O                  |                                |\n+---------+-----------+---------------------------------------+--------------------------------+</code></pre></div>\n<p>Here you go, the JavaScript model. A single-threaded, event-driven asynchronous programming model.</p>\n<h3 id=\"introducing-cooperative-scheduling\" style=\"position:relative;\"><a href=\"#introducing-cooperative-scheduling\" aria-label=\"introducing cooperative scheduling permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Introducing: Cooperative Scheduling</h3>\n<p>Make no assumption about the runtime environment, language feature, hardware architecture,\nor anything else. Consider the following code:</p>\n<div class=\"gatsby-highlight\" data-language=\"py\"><pre class=\"language-py\"><code class=\"language-py\">p <span class=\"token operator\">=</span> <span class=\"token number\">10</span>\n<span class=\"token keyword\">print</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span></code></pre></div>\n<p>Can you guarantee that the output for <code class=\"language-text\">print(p)</code> is 10? No you cannot, the OS might simply\nstop this thread from executing, switch to another thread, which might modify the value of <code class=\"language-text\">p</code>.</p>\n<p>To make sure that there is no more than 2 “threads” at the same time, or more\naccurately, any lines of continuous code in a block need to execute\ncontinuously, JavaScript guarantees that no other event can execute before\nthe current event finish executing. Again, the end of execution is defined by\nthe fact that the call stack is empty. That means a chunk of code needs\nto “willingly” give up control and let other code execute, instead of having\nthe runtime/OS take away your control.</p>\n<p>This is the famous JavaScript <strong>“run to completion”</strong> guarantee. The event is completed\nwhen the callstack is empty, and no other event/function/callback/whatever can\nrun while the current event is not done.</p>\n<h3 id=\"opposite-side-preemptive-scheduling\" style=\"position:relative;\"><a href=\"#opposite-side-preemptive-scheduling\" aria-label=\"opposite side preemptive scheduling permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Opposite Side: Preemptive Scheduling</h3>\n<p>In cooperative scheduling, control of execution/CPU is handled by each unit\nof work. Nothing else can take away the control. The work in the CPU currently\nis the only one to decide when to give up the control. However, in preemptive\nscheduling, there is a main controller/scheduler that decides when to run what. In the\ncontext of OS, the OS scheduler is the boss that decides who gets the\ncontrol of execution/CPU. It is the boss therefore it has to power to stop the\nexecution of a certain execution of unit of work. The code above then might\nnot print <code class=\"language-text\">10</code>. Since the OS has the power to decide, it can also decide what\nprocess get higher priority of execution.</p>\n<h2 id=\"problem-with-react-in-dom\" style=\"position:relative;\"><a href=\"#problem-with-react-in-dom\" aria-label=\"problem with react in dom permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Problem with React in DOM</h2>\n<p>After reviewing some basic scheduling concept and the JavaScript runtime, let’s\nlook at what problem React is facing that it needs to be solved with Fiber.</p>\n<p>React thinks of UI as a function of state:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">ui = f(s)</code></pre></div>\n<p>In a DOM environment, the UI is the DOM tree. React in the DOM is responsible to\ngenerate a virtual DOM tree.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">Render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   vdom <span class=\"token operator\">=</span> <span class=\"token function\">reactRenderElement</span><span class=\"token punctuation\">(</span>rootOfReactComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token function\">mountVdomOntoDom</span><span class=\"token punctuation\">(</span>vdom<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>How do we generate the virtual dom tree? What is the implementation of <code class=\"language-text\">reactRenderElement</code>?\nIt might be a recursion:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">reactRenderElement</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">el</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> \n      <span class=\"token keyword\">return</span> el<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">return</span> el<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">c</span> <span class=\"token operator\">=></span> <span class=\"token function\">reactRenderElement</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<h2 id=\"problem-with-cooperative-scheduling-in-dom\" style=\"position:relative;\"><a href=\"#problem-with-cooperative-scheduling-in-dom\" aria-label=\"problem with cooperative scheduling in dom permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Problem with Cooperative Scheduling in DOM</h2>\n<p>If an event takes too long to execute, no other event, including painting (aka drawing\nthe stuff on the screen so user can see it, which should happen 60 times per second) can happen.\nThe rendering frame drops. With React, this can happen when the tree is too big, <code class=\"language-text\">Render</code> takes to long.\nThis rendering time complexity scales at least linearly with the number of nodes/components.</p>\n<p>The main problem here, then, is that there is <strong>only one single event to render the whole tree</strong>.\nTherefore, it blocks painting and therefore bad for user experience. Now we know the problem\nwe are solving.</p>\n<h2 id=\"solution-asyncawait\" style=\"position:relative;\"><a href=\"#solution-asyncawait\" aria-label=\"solution asyncawait permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Solution: <code class=\"language-text\">async/await</code></h2>\n<p>JavaScript has now a nice abstraction around the asynchronous callback mechanism,\ncalled <code class=\"language-text\">async/await</code>. We can use this to break our one event into several event.\nEach level of function call/recursion is its own event. Each one of them would be so short\nand therefore solves our problem.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">Render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   vdom <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">reactRenderElement</span><span class=\"token punctuation\">(</span>rootOfReactComponent<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token function\">mountVdomOntoDom</span><span class=\"token punctuation\">(</span>vdom<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">reactRenderElement</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">el</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> \n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">await</span> el<span class=\"token punctuation\">.</span><span class=\"token function\">render</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">return</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">All</span><span class=\"token punctuation\">(</span>el<span class=\"token punctuation\">.</span>children<span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">c</span> <span class=\"token operator\">=></span> <span class=\"token function\">reactRenderElement</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Easy right? Our recursion is instantly non-blocking anymore. However, we\nare wasting a lot of time creating events (or micro-tasks) and each time we\nreturn, we need to go to the eventloop to ask for the next task to process.\nCan we make this better?</p>\n<blockquote>\n<p>The manifestation of inefficiency can be shown with the following code:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">let</span> start<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// synchronous recursion</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> \n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>performance<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n   <span class=\"token keyword\">else</span> \n      <span class=\"token function\">a</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">// asynchronous recursion</span>\n<span class=\"token keyword\">async</span> <span class=\"token keyword\">function</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span> \n   <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>n <span class=\"token operator\">&lt;=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> \n      console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>performance<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> start<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n   <span class=\"token keyword\">else</span> \n      <span class=\"token keyword\">await</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span>n<span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">p</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">f<span class=\"token punctuation\">,</span> n</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   start <span class=\"token operator\">=</span> performance<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">p</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> <span class=\"token number\">1500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">p</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">,</span> <span class=\"token number\">1500</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>The main focus is how much time is spend only on going around the event loop.\nIt takes around 1ms to recurse 1500 times with <code class=\"language-text\">async/await</code>, which means 1/16\nof time per frame (assuming 60fps) is wasted just on the eventloop. That is quite\na bit of time! I took 1500 since <a href=\"https://web.dev/dom-size/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Google says</a> it\nis the maximum acceptable number of DOM nodes to have before your web page\nis flagged by Lighthouse as inefficient.</p>\n</blockquote>\n<p>So, it is better to batch computation in one event since using callstack incurs\nlow cost, but using event is costly. But we still need to do so without\noccupying the event loop too much. In summary, we need to pause work and come\nback to it later. However, how can we do so since the callstack will be\ncleared every time we give up the CPU?</p>\n<p>Solution: we cannot use recursion. Instead, we manage the execution\nourselves. Instead of recursion, we save the state (both the result of\nexecution and where we are currently in the execution) and do it next time.</p>\n<h2 id=\"fiber\" style=\"position:relative;\"><a href=\"#fiber\" aria-label=\"fiber permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Fiber</h2>\n<p>So what is fiber?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">fiber | AmE ˈfaɪbər | noun\n   countable (filament, strand of yarn, wood, muscle, nerve)</code></pre></div>\n<p>and what is a thread?</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">thread | AmE θrɛd | noun\n   uncountable and countable (string)</code></pre></div>\n<p>We are all quite familiar with the term “thread”. Therefore, we can\nbuild our understanding of “fiber” from the concept of “thread”.\nThey are very similar concept, the smallest unit of execution that a\nscheduler can control. So, Fiber is an abstraction that React uses to\nrepresent a smallest unit of work. But unlike thread, a fiber cannot be\ninterrupted since JavaScript uses cooperative scheduling.</p>\n<p>So how exactly are fiber scheduled in a cooperative scheduling environment\nlike the DOM that runs with a JavaScript runtime. Let’s have an abstract\nmethod called <code class=\"language-text\">shouldYieldToHost()</code> that represents when we need to give the\ncontrol back to the main event loop. And each fiber is a function. We do the\nfollowing:</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">executeReactEvent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n   <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      task <span class=\"token operator\">=</span> <span class=\"token function\">getNextFiber</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>task <span class=\"token operator\">===</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">||</span> <span class=\"token function\">shouldYieldToHost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n         <span class=\"token comment\">// before we yield, schedule another run.</span>\n         <span class=\"token comment\">// actually React uses `postMessage`, since it is faster.</span>\n         <span class=\"token function\">setTimeout</span><span class=\"token punctuation\">(</span>executeReactEvent<span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n         <span class=\"token keyword\">return</span>\n      <span class=\"token punctuation\">}</span>\n      <span class=\"token function\">task</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n   <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>Take a look at how <code class=\"language-text\">setTimeout(f, 0)</code> and <code class=\"language-text\">postMessage</code> differs in\nperformance: <a href=\"https://stackoverflow.com/q/18826570\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://stackoverflow.com/q/18826570</a></p>\n</blockquote>\n<p>This means that React essentially implemented their own scheduler. It is\nstill cooperative scheduling relative to the JavaScript runtime. But it is\npreemptive scheduling with respect to the rendering event. It can be\ninterrupted in the middle, since the rendering event is broken down into\nmultiple fibers.</p>\n<blockquote>\n<p>The source code for this imaginary <code class=\"language-text\">executeReactEvent</code> can be found in\n<code class=\"language-text\">workloop</code> of React Scheduler package.</p>\n</blockquote>\n<p>Now, how does React break down the entire rendering process into single\nunits of work (fiber)? The job of the rendering process is essentially\nto render the virtual DOM tree. Since it is a tree, a very natural\nunit of work is each single node. And yes, it is exactly how each\nunit of fiber correspond to in React.</p>\n<p>But now here is the issue, in React we uses a one-way data flow by having\nthe parent components passing it down to child components. If Fiber were\nto separate things into individual functions, how does fiber pass data\nto each other? How does parent pass <code class=\"language-text\">props</code> to children?</p>\n<p>Here is where the Fiber node data structure comes in: it tracks several\nthings:</p>\n<ul>\n<li><code class=\"language-text\">types</code> (example: <code class=\"language-text\">\"div\"</code>, <code class=\"language-text\">\"span\"</code>, <code class=\"language-text\">MyComponent</code>)</li>\n<li><code class=\"language-text\">props</code> passed</li>\n<li><code class=\"language-text\">children</code> and <code class=\"language-text\">siblings</code></li>\n<li><code class=\"language-text\">return</code> (parent component)</li>\n</ul>\n<p>This is essentially keeping track of a stack frame! <code class=\"language-text\">props</code> are the\narguments, <code class=\"language-text\">return</code> specifies which fiber it returns to. <code class=\"language-text\">children</code> and\n<code class=\"language-text\">siblings</code> are for scheduler to know what is the next fiber to execute. This\nis how we traverse through the tree.</p>\n<p>Here you go. we have specified how to traverse through the tree,\norder of traversal (<code class=\"language-text\">children</code>, <code class=\"language-text\">siblings</code>), return relationships (who\nis the parent function or the caller), and a working scheduler to schedule all these works.</p>\n<p>However, this only generates the vdom, we still haven’t actually modified\nthe DOM. This phase of creating the VDOM is called render phase. Then,\nit updates the DOM by traversing through the VDOM and applying the changes.\nThis step cannot be broken into fiber. There are 2 reasons:</p>\n<ol>\n<li>if it is, partial DOM updates happens and create UI inconsistency</li>\n<li>DOM update in batch of an event is quick</li>\n</ol>\n<p>This phase of applying changes to the actual DOM is called commit phase.</p>\n<p>This gives us a hint of a 2 phase commit, which means that the first phase\nis interruptable, and indeed it is but we are not going into detail of this.</p>\n<h2 id=\"visualizing-fiber\" style=\"position:relative;\"><a href=\"#visualizing-fiber\" aria-label=\"visualizing fiber permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Visualizing Fiber</h2>\n<p>We can visualize the difference between using fiber to render and using\ncallstack to render. Pay attention to the callstack and how it renders.\n<a href=\"https://claudiopro.github.io/react-fiber-vs-stack-demo/\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">demo here</a>.</p>\n<h2 id=\"furthermore\" style=\"position:relative;\"><a href=\"#furthermore\" aria-label=\"furthermore permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Furthermore</h2>\n<p>There are more interesting things that having control of the scheduler\nthat enables React to do, for example, determines which update are of\nhigher priority and apply them first. Split work potentially into workers?\n(the React core team have actually <a href=\"https://github.com/web-perf/react-worker-dom\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">tried this</a>,\nand it <a href=\"https://github.com/facebook/react/issues/3092\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">gave birth</a> to Fiber!)\nWe will not go into the detail here.</p>\n<h2 id=\"how-does-it-effect-us\" style=\"position:relative;\"><a href=\"#how-does-it-effect-us\" aria-label=\"how does it effect us permalink\" class=\"gatsby-remark-autolink-headers-a-tags before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>How does it effect us?</h2>\n<p>In short, not really, but some APIs have changed due to the new scheduling mechanism.</p>\n<ul>\n<li><code class=\"language-text\">componentWillMount</code></li>\n<li><code class=\"language-text\">componentWillReceiveProps</code></li>\n<li><code class=\"language-text\">componentWillUpdate</code></li>\n</ul>\n<p>These APIs have been marked as unsafe. For the reason being that we cannot be\ncertain when the mount/update/receive props would happen since the scheduler is\nnon-deterministic.</p>\n<p>However, this sets up ground for suspense and data fetching. Our render can\nbe interrupted, wait until the data is done, and we can come back to it later.\nThis will largely change how we write our component and fetch data in the future.</p>\n<p>In summary, what Fiber really is is <strong>a balance/compromise between going absolutely crazy\nwith <code class=\"language-text\">async/await</code> by turing every single function call into a callback and keeping\neverything in one single task/event</strong>.</p>\n<p>But it also presents an approach that allows us to preemptively schedule in a\ncooperative environment. But fundamentally, it is still the principle of\nsplitting up large task into smaller ones. Here, I quote from the book ”<a href=\"https://books.google.com.hk/books/about/JavaScript_Patterns.html?id=WTZqecc9olUC&#x26;source=kp_book_description&#x26;redir_esc=y\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">JavaScript\nPatterns</a>“:</p>\n<blockquote>\n<p>The idea is to split a big amount of work into smaller chunks and perform each chunk\nwith a timeout of 1ms.</p>\n</blockquote>\n<p>Thank you.</p>","frontmatter":{"date":"2020-06-22","title":"My Two Cents on Fiber","subtitle":"No, it is not all about React."},"timeToRead":11}},"pageContext":{"slug":"/2020-06-22-my-two-cents-on-fiber/","prev":{"title":"Galen Cooks Food the Wong Way","path":"/blog/2020-08-01-galen-cooks-food-the-wong-way/"},"next":{"title":"台灣音樂的反思——香港與粵語文化的輸出","path":"/blog/2020-03-24-香港文化輸出/"}}},"staticQueryHashes":["1827841","1979163989"]}